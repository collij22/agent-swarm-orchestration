#!/usr/bin/env python3
"""
FINAL COMBINED FIX - Merges all working solutions
- Tool schema fixes from fix_specific_tools.py (was working)
- Write_file content parameter fix
- Proper async structure that was working before
- I/O closed file fix
"""

import sys
import os
import asyncio
import json
from typing import Dict, Any, Optional

# Fix for I/O closed file issue - bypass Rich console
class FakeRichModule:
    """Fake rich module to prevent I/O issues"""
    class Console:
        def __init__(self, *args, **kwargs):
            pass
        def print(self, *args, **kwargs):
            print(*args)
        def log(self, *args, **kwargs):
            print(*args)
        def status(self, *args, **kwargs):
            from contextlib import nullcontext
            return nullcontext()
    
    class Progress:
        def __init__(self, *args, **kwargs):
            pass
        def __enter__(self):
            return self
        def __exit__(self, *args):
            pass
        def add_task(self, *args, **kwargs):
            return 0
        def update(self, *args, **kwargs):
            pass

# Install fake rich module BEFORE any imports
sys.modules['rich'] = FakeRichModule()
sys.modules['rich.console'] = FakeRichModule()
sys.modules['rich.progress'] = FakeRichModule()

# Add project root to path
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

def generate_comprehensive_content(file_path: str, agent_name: str = None) -> str:
    """Generate appropriate content based on file type"""
    _, ext = os.path.splitext(file_path)
    ext = ext.lower()
    
    content_map = {
        '.py': '''"""Module generated by agent swarm"""

def main():
    """Main function"""
    raise NotImplementedError(f"Implementation pending for {os.path.basename(file_path)}")

if __name__ == "__main__":
    main()
''',
        '.js': '''// Module generated by agent swarm
module.exports = {
    init: function() {
        throw new Error(`Implementation pending for ${path.basename(file_path)}`);
    }
};''',
        '.ts': '''// TypeScript module generated by agent swarm
export function init(): void {
    throw new Error(`Implementation pending`);
}''',
        '.tsx': '''import React from 'react';

export default function Component() {
    return <div>Implementation pending</div>;
}''',
        '.jsx': '''import React from 'react';

export default function Component() {
    return <div>Implementation pending</div>;
}''',
        '.json': '{\n  "status": "pending",\n  "message": "Content to be implemented"\n}',
        '.yaml': 'status: pending\nmessage: Content to be implemented\n',
        '.yml': 'status: pending\nmessage: Content to be implemented\n',
        '.md': f'# {os.path.basename(file_path)}\n\nContent to be implemented.\n',
        '.html': '''<!DOCTYPE html>
<html>
<head><title>Pending</title></head>
<body><h1>Implementation pending</h1></body>
</html>''',
        '.css': '/* Styles to be implemented */\nbody { margin: 0; padding: 0; }\n',
        '.scss': '// SCSS styles to be implemented\nbody { margin: 0; padding: 0; }\n',
        '.sh': '#!/bin/bash\n# Script to be implemented\necho "Implementation pending"\n',
        '.bat': '@echo off\nREM Script to be implemented\necho Implementation pending\n',
        '.env': '# Environment variables\n# TODO: Add configuration\n',
        '.gitignore': '# Files to ignore\nnode_modules/\n*.pyc\n.env\n',
        '.dockerfile': 'FROM python:3.11\n# Container configuration pending\n',
        'dockerfile': 'FROM python:3.11\n# Container configuration pending\n',
        '.sql': '-- SQL script to be implemented\n-- TODO: Add queries\n',
        '.xml': '<?xml version="1.0"?>\n<root><!-- Content pending --></root>\n',
        '.ini': '[settings]\n; Configuration pending\n',
        '.conf': '# Configuration file\n# Settings to be added\n',
        '.txt': 'Content to be implemented.\n',
    }
    
    return content_map.get(ext, f'# Content pending for {os.path.basename(file_path)}\n')

# Monkey-patch the orchestrator's tool converter BEFORE import
def patch_orchestrator():
    """Apply all necessary patches to the orchestrator"""
    
    # First, let's patch the tool schema converter
    import lib.agent_runtime as runtime_module
    
    original_tool_converter = None
    
    def fixed_tool_converter(self, tool):
        """Fixed converter that handles 'any' type and missing 'items'"""
        from lib.schemas.tool import Tool
        
        # Handle both Tool objects and dicts
        if hasattr(tool, '__dict__'):
            tool_dict = tool.__dict__ if not callable(getattr(tool, 'dict', None)) else tool.dict()
        else:
            tool_dict = tool if isinstance(tool, dict) else {'name': str(tool), 'description': '', 'parameters': {}}
        
        # Build the schema
        properties = {}
        required = []
        
        # Type conversion map
        type_map = {
            "any": "string",  # Convert 'any' to 'string'
            "str": "string",
            "int": "integer", 
            "float": "number",
            "bool": "boolean",
            "list": "array",
            "dict": "object",
            "array": "array",
            "object": "object"
        }
        
        # Get parameters based on tool type
        if 'parameters' in tool_dict:
            params = tool_dict['parameters']
            if isinstance(params, dict):
                # Handle the properties field if it exists
                if 'properties' in params:
                    param_props = params['properties']
                elif 'type' in params and params['type'] == 'object':
                    param_props = params.get('properties', {})
                else:
                    param_props = params
                    
                # Process required fields
                if 'required' in params:
                    required = params['required'] if isinstance(params['required'], list) else []
            else:
                param_props = {}
        else:
            param_props = {}
        
        # Process each parameter
        for param_name, param_info in param_props.items():
            if isinstance(param_info, dict):
                param_type = param_info.get('type', 'string')
                
                # Convert type
                param_type = type_map.get(param_type, param_type)
                
                # Build property
                prop = {"type": param_type}
                
                # Add description if present
                if 'description' in param_info:
                    prop["description"] = param_info['description']
                
                # Handle arrays - ensure 'items' exists
                if param_type == "array":
                    if "items" not in param_info:
                        # Add default items
                        prop["items"] = {"type": "string"}
                    else:
                        prop["items"] = param_info["items"]
                
                # Handle nested objects
                if param_type == "object" and "properties" in param_info:
                    prop["properties"] = param_info["properties"]
                    if "required" in param_info:
                        prop["required"] = param_info["required"]
                
                # Copy other fields
                for key in ['enum', 'default', 'minimum', 'maximum', 'minItems', 'maxItems']:
                    if key in param_info:
                        prop[key] = param_info[key]
                
                properties[param_name] = prop
        
        return {
            "type": "function",
            "function": {
                "name": tool_dict.get('name', 'unknown'),
                "description": tool_dict.get('description', ''),
                "parameters": {
                    "type": "object",
                    "properties": properties,
                    "required": required,
                    "additionalProperties": False
                }
            }
        }
    
    # Patch the AnthropicAgentRunner class
    if hasattr(runtime_module, 'AnthropicAgentRunner'):
        runtime_module.AnthropicAgentRunner._tool_to_schema = fixed_tool_converter
    
    # Now patch the execute_tool method to handle write_file
    original_execute = None
    if hasattr(runtime_module, 'AnthropicAgentRunner'):
        original_execute = runtime_module.AnthropicAgentRunner._execute_tool
    
    async def enhanced_execute_tool(self, tool, args, context, agent_name=None):
        """Enhanced tool execution with write_file content fix"""
        # Special handling for write_file
        if hasattr(tool, 'name') and tool.name == "write_file":
            if "content" not in args or not args.get("content"):
                file_path = args.get("file_path", "unknown")
                print(f"⚠️ Warning: write_file missing content for {file_path}, generating placeholder")
                args["content"] = generate_comprehensive_content(file_path, agent_name)
                
                # Track for later fix
                if not hasattr(context, 'artifacts'):
                    context.artifacts = {}
                if 'files_needing_fix' not in context.artifacts:
                    context.artifacts['files_needing_fix'] = []
                context.artifacts['files_needing_fix'].append(file_path)
        
        # Call original
        if original_execute:
            return await original_execute(self, tool, args, context)
        else:
            # Fallback implementation
            if hasattr(tool, 'execute'):
                return await tool.execute(**args)
            return None
    
    # Apply the patch
    if hasattr(runtime_module, 'AnthropicAgentRunner'):
        runtime_module.AnthropicAgentRunner._execute_tool = enhanced_execute_tool
    
    print("✅ Patches applied successfully")

# Apply patches BEFORE any imports
patch_orchestrator()

# Now import the orchestrator
from orchestrate_enhanced import main

async def run():
    """Run the orchestrator with patches applied"""
    # Set up arguments for QuickShop MVP
    original_argv = sys.argv.copy()
    
    sys.argv = [
        "orchestrate_enhanced.py",
        "--requirements", "projects/quickshop-mvp-test6/requirements.yaml",
        "--max-parallel", "3",
        "--dashboard",
        "--progress",
        "--human-log",
        "--verbose"
    ]
    
    try:
        print("🚀 Starting Enhanced Agent Swarm Orchestrator")
        print("=" * 60)
        print("Project: QuickShop MVP Test 6")
        print("Agents: 15 specialized agents")
        print("Features: Phase 1-5 enhancements enabled")
        print("MCPs: All 7 MCPs enabled")
        print("=" * 60)
        
        # Run the main orchestrator
        result = await main()
        
        print("\n✅ Orchestration complete!")
        return result
        
    except Exception as e:
        print(f"\n❌ Orchestration failed: {e}")
        import traceback
        traceback.print_exc()
        return None
    finally:
        sys.argv = original_argv

if __name__ == "__main__":
    # Run with asyncio
    asyncio.run(run())